---
title: Raft
subtitle:
date: 2024-10-30T14:03:13+08:00
slug: 49eacb6
draft: false
author:
  name:
  link:
  email:
  avatar:
description:
keywords:
license:
comment: false
weight: 0
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRelated: false
hiddenFromFeed: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: false
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---



https://zhuanlan.zhihu.com/p/142035411


## 状态机

节点的状态机如下

![](/raft.png)

候选者,领导者,追随者

首先应用都是追随者, 并各自运行一个超时时间不同的定时器. 某个节点超时时间到期后状态变成候选者, 任期+1, 向其他节点发送RV请求, 请求中包含本节点id和任期. 
如果RV响应对方节点的任期相同且投票给当前候选节点, 那本节点就任务收到了选票, 如果选票大于一半, 那当前节点就成为领导者.
如果RV响应的任期大于当前节点的任期, 那么从候选者变成追随者.

每个追随者都会持续运行的定时器，每次接收到当前领导者的消息时就重新启动它。领导者会发送周期性的心跳，因此当追随者接收不到这些心跳信号时，他会认为当前领导者出现故障或者断开连接，并开始新一轮选举（切换为候选者状态）。

选举定时器的超时时间是随机的.

如果追随者出现网络分区, 那它将会在超时后变成候选者, 但其不会收到多数投票, 因此无法成为领导者, 将会不断在候选者上自旋.

变成领导者后, 会周期性发送心跳, 即没有内容的AE请求, 如果AE响应高于当前节点的任期, 那么当前节点变成追随者.

## 领导者网络分区

领导者分区后, 追随者在超时结束后发现没有收到心跳, 转变成候选者, 其中只有已被commit的日志index最大的才有可能成为新的leader.

成为新的leader后任期+1, 因此老的领导者重新上线会发现当前任期比自己的大, 转变为追随者.

## 追随者网络分区

想象一个有三台服务器A，B和C的集群。假设A是领导者，起始任期是1，并且集群正在完美运行着。A每隔50ms都想B、C发一次心跳AE请求，并在几毫秒内得到及时响应。每一次的AE请求都会重置B、C中的electionResetEvent属性，因此它们也都很愿意继续做追随者。

在某个时刻，由于网络路由器的临时故障，服务器B与A、C之间出现了网络分区。A仍然每隔50ms发一次AE请求，但是这些AE要求要么立即失败，或者是由于底层RPC引擎的超时导致失败。A对此无能为力，但是问题也不大。我们目前还没有涉及到日志复制，但是因为3台服务器中的2台都是正常的，集群仍然可以提交客户端指令。

那么B呢？假设在断开连接的时候，它的选举超时设置为了200ms。在断开连接大约200ms后，B的runElectionTimer会意识到在选举等待时间内没有收到领导者的信息，B无法区分是谁出了错，所以它就变为了候选者并开启一轮选举。

因此B的任期将变为2（而A和C的任期仍然是1）。B会向A和C发送RV请求，要求他们为自己投票；当然，这些请求会丢失在网络中。不要惊慌！B中的startElection方法也启动了另一个goroutine执行runElectionTimer任务，假设这个goroutine会等待250ms（要记住，我们的超时时间是在150ms-300ms之间随机选择的），以查看上一轮选举是否出现实质性的结果。因为B仍然被完全隔离，也就不会发生什么，因此runElectionTimer会发起另一轮选举，并将任期增加到3。

如此这般，B的服务器在几秒钟之后自我重置并重新上线，与此同时，B由于每隔一段时间都发起选举，它的任期已经变为8。

这时网络分区问题已经修复，B重新连接到了A和C。

不久之后，A发送的AE请求到了。回想一下，A每隔50ms都会发送心跳信息，即使B一直没有回复。

B的AppendEntries被调用，并且回复信息中携带的任务为8.

A在leaderSendHeartbeats方法中收到此回复，检查回复信息中的任期后发起比自己的任期更高。A将自身的任期改为8并变成追随者。集群暂时失去了领导者。

接下来根据定时的不同，可能会出现多种情况。B是候选者，但是它可能在网络恢复之前已经发送了RV请求；C是追随者，但是由于在选举超时内没有收到A的AE请求，也会变成候选人；A变成了追随者，也可能因为选举超时变成候选人。

所以其中任何一个服务器都可能在下一轮的选举中胜选，注意，这只是因为我们在这里并没有复制任何日志。我们将在下一部分看到，实际情况下，A和C可能会在B离线的时候添加了一些写的客户端指令，因此它们的日志是最新的。因此，B不会变成新的领导者——会出现新的一轮选举，而且A或C会胜选。在下一部分我们会再次讨论这个场景。

假如在B断开连接之后没有新增任何指令，则重新连接之后更换领导者也是完全可以的。

看起来可能有些效率低下——确实如此。这里更换领导者是不必要的，因为A在整个场景中都是非常健康的。但是，以牺牲特殊情况下的效率为代价，保证算法逻辑的简单性，这也是Raft做出的选择之一。算法在一般情形（没有任何异常）下的效率更重要，因为集群99.9%的时间都处于该状态。

## RPC
Raft协议中，同伴间会发送两类RPC请求。详细的参数和规则可以参考论文中的Figure 2，或者本文的附录。这里简单说明一下两种请求：

RequestVote(RV)：只有候选人状态下会使用。在一轮选举中，候选人通过该接口向同伴请求选票。返回值中包含是否同意投票的标志。
AppendEntries(AE)：只有领导者状态下使用。领导者通过该RPC将日志条目复制给追随者，也用来发送心跳。即使没有要复制的日志条目，也会定期向追随者发送该RPC请求。
